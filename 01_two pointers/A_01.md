https://codeforces.com/problemset/problem/1167/E

输入 n(1≤n≤1e6) x(1≤x≤1e6) 和长为 n 的数组 a(1≤a[i]≤x)。

定义 D(a,L,R) 为删除 a 中所有元素值在 [L,R] 中的元素后，剩余的元素组成的数组（不改变顺序）。

输出有多少对 (L,R) 满足 1<=L<=R<=x 且 D(a,L,R) 是非降数组，即相邻元素左边 <= 右边。



```c++
#include<bits/stdc++.h>
const int N = 1e6 + 5;
using i64 = long long;
int n,m,x;
int T = 1;
struct node {
    int l,r,v;
}a[N];
void solve() {
    std::cin >> n >> x;
    for(int i = 0;i < N;++i) {
        a[i].l = a[i].r = -1; a[i].v = i;
    }
    for(int i = 1;i <= n;++i) {
        int v; std::cin >> v;
        if(a[v].l == -1) a[v].l = i;
        a[v].r = i;
    }
    std::vector<node> b;
    for(auto o : a) {
        if(o.l != -1) b.push_back(o);
    }
    // for(auto o:b) {
    //     std::cout << o.l << ' ' << o.r << ' ' << o.v << '\n';
    // }
    m = b.size();
    int i = 0;
    while(i < m - 1 && b[i].r < b[i + 1].l) {
        i += 1;
    }
    if(i == m - 1) {
        std::cout << (i64)x * (x + 1) / 2 << '\n';
        return;
    }
    i64 ans = (i64)b[i + 1].v * (x - b[m - 1].v + 1);
    for(int j = m - 1;(j == m - 1) || (b[j].r < b[j + 1].l);--j) {
        while(i >= 0 && b[i].r >= b[j].l) {
            i -= 1;
        }
        ans += (i64)b[i + 1].v * (b[j].v - b[j - 1].v);
    }
    std::cout << ans << '\n';
}

int main() {
    std::ios::sync_with_stdio(false);std::cin.tie(nullptr);std::cout.tie(nullptr);
    for(int _ = 0;_ < T;++ _) {
        solve();
    }
}
```

