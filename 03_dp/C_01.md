### 一、问题描述

给定一个长度为`n`的`target`数组，所有元素都是大于等于`0`的，每次操作可以将一段子数组减`1`。

问：最少需要多少次可以将`target`数组变化为`[0,0,0...]`？

例子： `target = [1,2,3,2,1]`

`[0,1,2,1,0] -> [0,0,1,0,0] -> [0,0,0,0,0]` 一共三次！



### 二、思路

设 `dp[i]`表示将前`i`个数变成`0`所需要的操作数！

`dp[0] = a[0]`

`if a[1] > a[0]`   ,`dp[1] = dp[0] + a[1] - a[0]`

`if a[1] <= a[0]` ,`dp[1] = dp[0]`



### 三、代码

```c++
int minNumberOperations(vector<int>& target) {
    int n = target.size();
    std::vector<int>dp(n);
    dp[0] = target[0];
    for(int i = 1;i < n;++i){
        if(target[i] > target[i - 1]){
            dp[i] = dp[i - 1] + target[i] - target[i - 1];
        }else{
            dp[i] = dp[i - 1];
        }
    }
    return dp.back();
}
```



